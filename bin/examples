#!/bin/bash

# Optimized Examples Helper Script
# This script manages example SecretProviderClasses with improved efficiency

set -euo pipefail

# Source configuration
source "$(dirname "${BASH_SOURCE[0]}")/../config.env"

# Check cluster authentication and permissions
check_cluster_auth() {
    # Check if oc is authenticated
    if ! oc whoami &>/dev/null; then
        print_error "Not authenticated to OpenShift cluster"
        print_info "Please authenticate using: oc login"
        return 1
    fi
    
    local current_user=$(oc whoami 2>/dev/null || echo "")
    print_info "Authenticated as: ${current_user}"
    
    # Check if user has cluster-admin permissions
    # Verify by checking if user can access cluster-scoped resources
    local has_cluster_access=false
    
    # Try to check permissions using oc auth can-i
    if oc auth can-i get clustercsidriver --all-namespaces &>/dev/null; then
        has_cluster_access=true
    elif oc auth can-i get csidriver --all-namespaces &>/dev/null; then
        has_cluster_access=true
    elif oc auth can-i '*' '*' --all-namespaces &>/dev/null 2>&1 | grep -q "yes"; then
        has_cluster_access=true
    fi
    
    # Fallback: Try to actually access a cluster-scoped resource
    if [ "$has_cluster_access" = false ]; then
        if oc get clustercsidriver &>/dev/null || oc get csidriver &>/dev/null || oc get namespace &>/dev/null; then
            has_cluster_access=true
        fi
    fi
    
    if [ "$has_cluster_access" = false ]; then
        print_warning "User '${current_user}' may not have cluster-admin permissions"
        print_info "Some operations may fail. Recommended: use a cluster-admin user"
        print_info "You can continue, but operations requiring cluster-scoped access may fail"
        # Continue anyway - let operations fail with clear errors
    else
        print_success "Cluster permissions verified"
    fi
    
    return 0
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${BLUE}================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}================================${NC}"
}

print_status() {
    echo -e "${YELLOW}➤${NC} $1"
}

print_success() {
    echo -e "${GREEN}✅${NC} $1"
}

print_error() {
    echo -e "${RED}❌${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ️${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠️${NC} $1"
}

# Check if Secrets Store CSI Driver operator is installed
check_sscsi_operator() {
    local OPERATOR_NAMESPACE="${OPERATOR_NAMESPACE:-openshift-cluster-csi-drivers}"
    
    # Check for CSV
    local csv_name=$(timeout 10 oc get csv -n ${OPERATOR_NAMESPACE} 2>/dev/null | grep "secrets-store-csi-driver-operator" | awk '{print $1}' | head -1 || echo "")
    
    if [ -n "${csv_name}" ]; then
        local csv_phase=$(oc get csv ${csv_name} -n ${OPERATOR_NAMESPACE} -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
        if [ "${csv_phase}" = "Succeeded" ]; then
            # Also check for ClusterCSIDriver (required for complete installation)
            if oc get clustercsidriver secrets-store.csi.k8s.io &>/dev/null; then
                return 0
            fi
        fi
    fi
    
    return 1
}

# Check if External Secrets Operator is installed
check_eso_operator() {
    local eso_csv=$(oc get csv -n external-secrets-operator 2>/dev/null | grep -E "openshift-external-secrets-operator|external-secrets-operator" | awk '{print $1}' | head -1 || echo "")
    
    if [ -n "${eso_csv}" ]; then
        local csv_phase=$(oc get csv ${eso_csv} -n external-secrets-operator -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
        if [ "${csv_phase}" = "Succeeded" ]; then
            return 0
        fi
    fi
    
    return 1
}

# Check if example requires a specific operator and if it's installed
check_example_requirements() {
    local example_name="$1"
    local basename="${example_name%.yaml}"  # Remove .yaml if present
    
    # Check if it's an ESO example
    if [[ "$basename" == *"eso"* ]]; then
        if ! check_eso_operator; then
            print_warning "Skipping ${basename}: External Secrets Operator is not installed"
            print_info "Install it with: ./bin/install install --eso"
            return 1
        fi
    # Check if it's an SSCSI example
    elif [[ "$basename" == *"secret-sync"* ]] || [[ "$basename" == *"namespace-based-rbac"* ]]; then
        if ! check_sscsi_operator; then
            print_warning "Skipping ${basename}: Secrets Store CSI Driver operator is not installed"
            print_info "Install it with: ./bin/install install --sscsi"
            return 1
        fi
    fi
    
    return 0
}

# Determine which operator an example belongs to
get_example_operator() {
    local example_name="$1"
    local basename="${example_name%.yaml}"  # Remove .yaml if present
    
    if [[ "$basename" == *"eso"* ]]; then
        echo "eso"
    elif [[ "$basename" == *"secret"* ]] || [[ "$basename" == *"namespace-based-rbac"* ]]; then
        # Match SSCSI examples: anything with "secret" (basic-secret-sync, mixed-secrets-sync) or namespace-based-rbac
        echo "sscsi"
    else
        echo "unknown"
    fi
}

# Get the appropriate namespace for an example based on its operator
# Each example gets its own namespace prefixed with the operator name
get_example_namespace() {
    local example_name="$1"
    local basename="${example_name%.yaml}"  # Remove .yaml if present
    local operator=$(get_example_operator "$example_name")
    
    # Generate namespace name: operator-basename
    # e.g., sscsi-basic-secret-sync, eso-externalsecret
    echo "${operator}-${basename}"
}

# Create namespace-specific secrets in Azure Key Vault for namespace-based-rbac examples
create_namespace_rbac_secrets() {
    local namespace="$1"
    local keyvault_name="$2"
    
    if [ -z "$namespace" ] || [ -z "$keyvault_name" ]; then
        print_warning "Missing namespace or Key Vault name, skipping secret creation"
        return 1
    fi
    
    # Check if Azure CLI is available
    if ! command -v az &> /dev/null; then
        print_warning "Azure CLI not found, cannot create namespace secrets"
        return 1
    fi
    
    # Check if authenticated
    if ! az account show &>/dev/null; then
        print_warning "Azure CLI not authenticated, cannot create namespace secrets"
        return 1
    fi
    
    # Secrets needed for namespace-based-rbac
    local db_secret_name="namespace-${namespace}-db-password"
    local api_secret_name="namespace-${namespace}-api-key"
    
    # Create database password secret if it doesn't exist
    if ! az keyvault secret show --vault-name "${keyvault_name}" --name "${db_secret_name}" &>/dev/null; then
        print_status "Creating namespace-specific secret: ${db_secret_name}"
        if az keyvault secret set \
            --vault-name "${keyvault_name}" \
            --name "${db_secret_name}" \
            --value "NamespaceSpecificPassword456!" \
            --only-show-errors 2>/dev/null; then
            print_success "Created ${db_secret_name}"
        else
            print_warning "Failed to create ${db_secret_name}"
        fi
    else
        print_info "${db_secret_name} already exists in Key Vault"
    fi
    
    # Create API key secret if it doesn't exist
    if ! az keyvault secret show --vault-name "${keyvault_name}" --name "${api_secret_name}" &>/dev/null; then
        print_status "Creating namespace-specific secret: ${api_secret_name}"
        if az keyvault secret set \
            --vault-name "${keyvault_name}" \
            --name "${api_secret_name}" \
            --value "namespace-api-key-xyz789" \
            --only-show-errors 2>/dev/null; then
            print_success "Created ${api_secret_name}"
        else
            print_warning "Failed to create ${api_secret_name}"
        fi
    else
        print_info "${api_secret_name} already exists in Key Vault"
    fi
    
    # Note: shared-readonly-config should already exist from install script
    # But verify it exists
    if ! az keyvault secret show --vault-name "${keyvault_name}" --name "shared-readonly-config" &>/dev/null; then
        print_status "Creating shared secret: shared-readonly-config"
        if az keyvault secret set \
            --vault-name "${keyvault_name}" \
            --name "shared-readonly-config" \
            --value "SharedConfigValue=readonly" \
            --only-show-errors 2>/dev/null; then
            print_success "Created shared-readonly-config"
        else
            print_warning "Failed to create shared-readonly-config"
        fi
    fi
    
    return 0
}

# Get the appropriate service account for an example based on its operator
# Service account name is based on the example namespace
get_example_service_account() {
    local example_name="$1"
    local basename="${example_name%.yaml}"  # Remove .yaml if present
    local operator=$(get_example_operator "$example_name")
    
    # Generate service account name: operator-basename-sa
    # e.g., sscsi-basic-secret-sync-sa, eso-externalsecret-sa
    echo "${operator}-${basename}-sa"
}

# Get example file path and operator
get_example_file() {
    local example_name="$1"
    local examples_root="$(dirname "${BASH_SOURCE[0]}")/../examples"
    
    # Try sscsi first
    local sscsi_file="$examples_root/sscsi/${example_name%.yaml}.yaml"
    if [ -f "$sscsi_file" ]; then
        echo "$sscsi_file"
        return 0
    fi
    
    # Try eso
    local eso_file="$examples_root/eso/${example_name%.yaml}.yaml"
    if [ -f "$eso_file" ]; then
        echo "$eso_file"
        return 0
    fi
    
    return 1
}

# Get operator from example file location
get_example_operator_from_file() {
    local example_file="$1"
    if [[ "$example_file" == *"/sscsi/"* ]]; then
        echo "sscsi"
    elif [[ "$example_file" == *"/eso/"* ]]; then
        echo "eso"
    else
        # Fallback: determine from filename/pattern
        get_example_operator "$(basename "$example_file" .yaml)"
    fi
}

# List available examples
list_examples() {
    print_header "Available Examples"
    
    local examples_root="$(dirname "${BASH_SOURCE[0]}")/../examples"
    local count=0
    
    # List SSCSI examples
    if [ -d "$examples_root/sscsi" ]; then
        print_status "Secrets Store CSI Driver Examples:"
        for file in "$examples_root/sscsi"/*.yaml; do
            if [ -f "$file" ]; then
                local basename=$(basename "$file" .yaml)
                local description=$(grep -E "^# Description:" "$file" 2>/dev/null | cut -d: -f2- | xargs || echo "No description")
                ((count++))
                echo -e "${GREEN}${count}.${NC} [SSCSI] ${basename}"
                echo -e "   ${description}"
                echo ""
            fi
        done
    fi
    
    # List ESO examples
    if [ -d "$examples_root/eso" ]; then
        print_status "External Secrets Operator Examples:"
        for file in "$examples_root/eso"/*.yaml; do
        if [ -f "$file" ]; then
            local basename=$(basename "$file" .yaml)
            local description=$(grep -E "^# Description:" "$file" 2>/dev/null | cut -d: -f2- | xargs || echo "No description")
                ((count++))
                echo -e "${GREEN}${count}.${NC} [ESO] ${basename}"
            echo -e "   ${description}"
            echo ""
        fi
    done
    fi
    
    if [ $count -eq 0 ]; then
        print_error "No examples found in $examples_root/sscsi/ or $examples_root/eso/"
        return 1
    fi
}

# Apply a specific example
apply_example() {
    local example_name="$1"
    
    # Find the example file
    local example_file
    if ! example_file=$(get_example_file "$example_name"); then
        print_error "Example not found: $example_name"
        print_info "Available examples:"
        list_examples
        return 1
    fi
    
    local basename=$(basename "$example_file" .yaml)
    print_status "Applying example: ${basename}"
    
    # Get operator from file location
    local operator=$(get_example_operator_from_file "$example_file")
    
    # Check if required operator is installed
    if ! check_example_requirements "$basename"; then
        return 0  # Return 0 (success) to not fail the script, but skip the example
    fi
    
    # Get the appropriate namespace for this example
    # We need to pass the operator to get_example_namespace, so we construct the namespace manually
    local example_namespace="${operator}-${basename}"
    local example_sa="${operator}-${basename}-sa"
    
    # Ensure required variables are set (from config.env)
    if [ -f "$(dirname "${BASH_SOURCE[0]}")/../config.env" ]; then
        source "$(dirname "${BASH_SOURCE[0]}")/../config.env" >/dev/null 2>&1
    fi
    
    # Ensure namespace exists
    print_status "Ensuring namespace exists: ${example_namespace}..."
    oc create namespace "${example_namespace}" --dry-run=client -o yaml | oc apply -f - 2>/dev/null || true
    
    # Initialize Azure values if not set
    if [ -z "${ACTUAL_KEYVAULT_NAME:-}" ] && [ -n "${KEYVAULT_NAME:-}" ]; then
        export AZURE_RESOURCE_PREFIX="${AZURE_RESOURCE_PREFIX:-aro-secrets-}"
        export ACTUAL_KEYVAULT_NAME="${AZURE_RESOURCE_PREFIX}${KEYVAULT_NAME}"
    fi
    
    # Export base64-encoded values for ESO examples (if not already set)
    if [ -z "${SERVICE_PRINCIPAL_CLIENT_ID_B64:-}" ] && [ -n "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ]; then
        export SERVICE_PRINCIPAL_CLIENT_ID_B64=$(echo -n "${SERVICE_PRINCIPAL_CLIENT_ID}" | base64)
    fi
    if [ -z "${SERVICE_PRINCIPAL_CLIENT_SECRET_B64:-}" ] && [ -n "${SERVICE_PRINCIPAL_CLIENT_SECRET:-}" ]; then
        export SERVICE_PRINCIPAL_CLIENT_SECRET_B64=$(echo -n "${SERVICE_PRINCIPAL_CLIENT_SECRET}" | base64)
    fi
    if [ -z "${AZURE_TENANT_ID_B64:-}" ] && [ -n "${AZURE_TENANT_ID:-}" ]; then
        export AZURE_TENANT_ID_B64=$(echo -n "${AZURE_TENANT_ID}" | base64)
    fi
    
    # Validate required variables
    local missing_vars=()
    if [ -z "${ACTUAL_KEYVAULT_NAME:-}" ]; then
        missing_vars+=("ACTUAL_KEYVAULT_NAME")
    fi
    if [ -z "${AZURE_TENANT_ID:-}" ]; then
        missing_vars+=("AZURE_TENANT_ID")
    fi
    if [ -z "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ]; then
        missing_vars+=("SERVICE_PRINCIPAL_CLIENT_ID")
    fi
    # TEST_NAMESPACE is no longer required as each example gets its own namespace
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        print_error "Missing required environment variables: ${missing_vars[*]}"
        print_info "Please ensure config.env is properly configured or run './bin/install azure' to set up Azure resources"
        return 1
    fi
    
    # Apply the example with environment variable substitution
    # Each example uses its own namespace, so we set all namespace variables to the same value
    export NAMESPACE="${example_namespace}"
    export TEST_NAMESPACE="${example_namespace}"
    export ESO_TEST_NAMESPACE="${example_namespace}"
    export KEYVAULT_NAME="${ACTUAL_KEYVAULT_NAME:-${KEYVAULT_NAME:-}}"
    
    # For namespace-based-rbac examples, ensure namespace-specific secrets exist in Key Vault
    if [[ "$basename" == "namespace-based-rbac" ]]; then
        print_status "Checking for namespace-specific secrets in Key Vault..."
        create_namespace_rbac_secrets "${example_namespace}" "${ACTUAL_KEYVAULT_NAME}"
    fi
    
    # Apply example using envsubst for variable substitution
    envsubst < "$example_file" | oc apply -f -
    
    # For SSCSI examples, ensure the service principal secret exists in the namespace
    if [[ "$operator" == "sscsi" ]]; then
        print_status "Ensuring service principal secret exists for SSCSI example..."
        local operator_namespace="openshift-cluster-csi-drivers"
        if ! oc get secret secrets-store-csi-driver-sp -n ${example_namespace} &>/dev/null 2>&1; then
            # Check if it exists in the operator namespace and copy it
            if oc get secret secrets-store-csi-driver-sp -n ${operator_namespace} &>/dev/null 2>&1; then
                print_status "Copying service principal secret from operator namespace..."
                oc get secret secrets-store-csi-driver-sp -n ${operator_namespace} -o yaml | \
                    sed "s/namespace: ${operator_namespace}/namespace: ${example_namespace}/" | \
                    sed '/^  resourceVersion:/d; /^  uid:/d; /^  selfLink:/d' | \
                    oc apply -f - 2>&1 || true
                # Add labels for cleanup
                oc label secret secrets-store-csi-driver-sp -n ${example_namespace} \
                    app=secrets-store-examples \
                    component=secret \
                    example="${basename}" \
                    --overwrite 2>/dev/null || true
            else
                # Create the secret directly using values from config.env
                if [ -n "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ] && [ -n "${SERVICE_PRINCIPAL_CLIENT_SECRET:-}" ]; then
                    print_status "Creating service principal secret in example namespace..."
                    oc create secret generic secrets-store-csi-driver-sp \
                        --from-literal=clientid="${SERVICE_PRINCIPAL_CLIENT_ID}" \
                        --from-literal=clientsecret="${SERVICE_PRINCIPAL_CLIENT_SECRET}" \
                        -n ${example_namespace} \
                        --dry-run=client -o yaml | oc apply -f - 2>&1 || true
                    # Add labels for cleanup
                    oc label secret secrets-store-csi-driver-sp -n ${example_namespace} \
                        app=secrets-store-examples \
                        component=secret \
                        example="${basename}" \
                        --overwrite 2>/dev/null || true
                    print_success "Service principal secret created"
                else
                    print_warning "Service principal credentials not found in config.env"
                    print_info "Example applied, but pods may not have access to Key Vault"
                    print_info "Ensure SERVICE_PRINCIPAL_CLIENT_ID and SERVICE_PRINCIPAL_CLIENT_SECRET are set"
                fi
            fi
        fi
        
        # Also ensure the service account exists with labels for cleanup
        print_status "Ensuring service account exists: ${example_sa}..."
        oc create serviceaccount ${example_sa} -n ${example_namespace} --dry-run=client -o yaml | oc apply -f - 2>/dev/null || true
        # Add labels for cleanup
        oc label serviceaccount ${example_sa} -n ${example_namespace} \
            app=secrets-store-examples \
            component=serviceaccount \
            example="${basename}" \
            --overwrite 2>/dev/null || true
    fi
    
    print_success "Example applied successfully!"
    
    # Show verification commands based on example type
    print_info "Verification commands:"
    if [[ "$operator" == "eso" ]]; then
        if [[ "$basename" == *"secretstore"* ]]; then
            echo "  oc get secretstore -n ${example_namespace}"
            echo "  oc describe secretstore azure-keyvault-secretstore -n ${example_namespace}"
            echo "  oc get secret azure-keyvault-sp -n ${example_namespace}"
        elif [[ "$basename" == *"externalsecret"* ]]; then
            echo "  oc get externalsecret -n ${example_namespace}"
            echo "  oc describe externalsecret hello-world-external-secrets -n ${example_namespace}"
            echo "  oc get secret hello-world-external-secrets-synced -n ${example_namespace}"
        fi
    else
        # Get actual SPC name from template
        local spc_name=$(grep -E "^metadata:" -A 5 "$example_file" | grep -E "^\s+name:" | awk '{print $2}' || echo "azure-keyvault-basic-secrets")
        echo "  oc get secretproviderclass -n ${example_namespace}"
        echo "  oc describe secretproviderclass ${spc_name} -n ${example_namespace}"
    fi
}

# Apply all examples
apply_all_examples() {
    print_header "Applying All Examples"
    
    # Check which operators are installed
    local sscsi_installed=false
    local eso_installed=false
    
    if check_sscsi_operator; then
        print_success "Secrets Store CSI Driver operator is installed"
        sscsi_installed=true
    else
        print_warning "Secrets Store CSI Driver operator is not installed - SSCSI examples will be skipped"
    fi
    
    if check_eso_operator; then
        print_success "External Secrets Operator is installed"
        eso_installed=true
    else
        print_warning "External Secrets Operator is not installed - ESO examples will be skipped"
    fi
    
    echo ""
    
    local applied_count=0
    local skipped_count=0
    local examples_root="$(dirname "${BASH_SOURCE[0]}")/../examples"
    
    # Apply all SSCSI examples
    if [ -d "$examples_root/sscsi" ]; then
        for file in "$examples_root/sscsi"/*.yaml; do
        if [ -f "$file" ]; then
            local basename=$(basename "$file" .yaml)
                if ! check_example_requirements "$basename"; then
                    skipped_count=$((skipped_count + 1))
                    echo ""
                    continue
                fi
            print_status "Applying $basename..."
                apply_example "$basename"
                if [ $? -eq 0 ]; then
                    applied_count=$((applied_count + 1))
                fi
                echo ""
        fi
    done
    fi
    
    # Apply all ESO examples
    if [ -d "$examples_root/eso" ]; then
        for file in "$examples_root/eso"/*.yaml; do
            if [ -f "$file" ]; then
                local basename=$(basename "$file" .yaml)
                if ! check_example_requirements "$basename"; then
                    skipped_count=$((skipped_count + 1))
                    echo ""
                    continue
                fi
                print_status "Applying $basename..."
                apply_example "$basename"
                if [ $? -eq 0 ]; then
                    applied_count=$((applied_count + 1))
                fi
                echo ""
            fi
        done
    fi
    
    if [ $skipped_count -gt 0 ]; then
        print_info "Applied ${applied_count} example(s), skipped ${skipped_count} example(s) due to missing operators"
    else
        print_success "Applied ${applied_count} example(s)"
    fi
}

# Apply all examples for a specific operator
apply_operator_examples() {
    local operator="$1"
    
    if [ -z "$operator" ]; then
        print_error "Please specify an operator: --sscsi or --eso"
        show_help
        return 1
    fi
    
    # Validate operator name
    if [[ "$operator" != "sscsi" ]] && [[ "$operator" != "eso" ]]; then
        print_error "Invalid operator: $operator"
        print_info "Valid operators: sscsi, eso"
        return 1
    fi
    
    # Check if operator is installed
    if [[ "$operator" == "sscsi" ]]; then
        if ! check_sscsi_operator; then
            print_error "Secrets Store CSI Driver operator is not installed"
            print_info "Install it with: ./bin/install install --sscsi"
            return 1
        fi
        print_header "Applying All Secrets Store CSI Driver Examples"
    elif [[ "$operator" == "eso" ]]; then
        if ! check_eso_operator; then
            print_error "External Secrets Operator is not installed"
            print_info "Install it with: ./bin/install install --eso"
            return 1
        fi
        print_header "Applying All External Secrets Operator Examples"
    fi
    
    local applied_count=0
    local skipped_count=0
    local examples_root="$(dirname "${BASH_SOURCE[0]}")/../examples"
    local example_dir=""
    
    if [[ "$operator" == "sscsi" ]]; then
        example_dir="$examples_root/sscsi"
    elif [[ "$operator" == "eso" ]]; then
        example_dir="$examples_root/eso"
    fi
    
    if [ ! -d "$example_dir" ]; then
        print_error "No examples found for operator: $operator"
        return 1
    fi
    
    for file in "$example_dir"/*.yaml; do
        if [ -f "$file" ]; then
            local basename=$(basename "$file" .yaml)
            print_status "Applying $basename..."
            if apply_example "$basename" 2>&1; then
                applied_count=$((applied_count + 1))
            else
                skipped_count=$((skipped_count + 1))
                print_warning "Failed to apply $basename, continuing with next example..."
            fi
            echo ""
        fi
    done
    
    if [ $skipped_count -gt 0 ]; then
        print_info "Applied ${applied_count} example(s), skipped ${skipped_count} example(s)"
    else
        local operator_upper=$(echo "$operator" | tr '[:lower:]' '[:upper:]')
        print_success "Applied ${applied_count} ${operator_upper} example(s) successfully!"
    fi
}

# Cleanup examples
# IMPORTANT: This function only cleans up example resources and test namespaces.
# It does NOT touch the installed operators (External Secrets Operator or Secrets Store CSI Driver).
cleanup_examples() {
    print_header "Cleaning Up Examples and Test Resources"
    print_info "Note: This cleanup will NOT affect installed operators"
    
    # Find all namespaces that match the pattern: sscsi-*, eso-*, or rbac-test-*
    local sscsi_namespaces=$(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n' | grep '^sscsi-' || true)
    local eso_namespaces=$(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n' | grep '^eso-' || true)
    local rbac_test_namespaces=$(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n' | grep '^rbac-test-' || true)
    
    # Clean up SSCSI example namespaces using label selectors
    if [ -n "$sscsi_namespaces" ]; then
        echo "$sscsi_namespaces" | while read -r ns; do
            if [ -n "$ns" ]; then
                print_status "Cleaning up SSCSI example namespace: $ns"
                
                # Clean up test pods using label selector
                oc delete pod -l app=secrets-store-test -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up SecretProviderClasses using label selector
                if oc api-resources | grep -q secretproviderclass; then
                    oc delete secretproviderclass -l app=secrets-store-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
                
                # Clean up CSI-managed secrets (created by SecretProviderClass secretObjects)
                oc delete secret -l secrets-store.csi.k8s.io/managed=true -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service principal secret using label selector
                oc delete secret -l app=secrets-store-examples,component=secret -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                # Fallback: delete by name
                oc delete secret secrets-store-csi-driver-sp -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service accounts using label selector
                oc delete serviceaccount -l app=secrets-store-examples,component=serviceaccount -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                # Fallback: also try naming pattern
                oc delete serviceaccount "${ns}-sa" -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Delete namespace (will cascade delete remaining resources)
                oc delete namespace "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
            fi
        done
        
        # Wait for deletions to complete
        print_status "Waiting for SSCSI resources to be deleted..."
        sleep 2
    else
        print_status "No SSCSI example namespaces found"
    fi
    
    # Clean up RBAC test namespaces (from namespace-based-rbac multi-namespace test)
    if [ -n "$rbac_test_namespaces" ]; then
        echo "$rbac_test_namespaces" | while read -r ns; do
            if [ -n "$ns" ]; then
                print_status "Cleaning up RBAC test namespace: $ns"
                
                # Clean up test pods using label selector
                oc delete pod -l app=secrets-store-test,example=namespace-based-rbac -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up SecretProviderClasses using label selector
                if oc api-resources | grep -q secretproviderclass; then
                    oc delete secretproviderclass -l app=secrets-store-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
                
                # Clean up CSI-managed secrets
                oc delete secret -l secrets-store.csi.k8s.io/managed=true -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service principal secret
                oc delete secret -l app=secrets-store-examples,component=secret -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                oc delete secret secrets-store-csi-driver-sp -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service accounts
                oc delete serviceaccount -l app=secrets-store-examples,component=serviceaccount -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                oc delete serviceaccount "${ns}-sa" -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Delete namespace
                oc delete namespace "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
            fi
        done
        
        print_status "Waiting for RBAC test resources to be deleted..."
        sleep 2
    else
        print_status "No RBAC test namespaces found"
    fi
    
    # Clean up ESO example namespaces using label selectors
    if [ -n "$eso_namespaces" ]; then
        echo "$eso_namespaces" | while read -r ns; do
            if [ -n "$ns" ]; then
                print_status "Cleaning up ESO example namespace: $ns"
                
                # Clean up ExternalSecrets using label selector
                if oc api-resources | grep -q externalsecret; then
                    oc delete externalsecret -l app=external-secrets-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
                
                # Clean up SecretStores using label selector
                if oc api-resources | grep -q secretstore; then
                    oc delete secretstore -l app=external-secrets-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
                
                # Clean up ESO-managed secrets (synced by ExternalSecret)
                # ESO adds owner references, but we can also clean up by naming pattern
                oc delete secret -l app=external-secrets-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service principal secret using label
                oc delete secret -l app=external-secrets-examples,component=secret -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Clean up service accounts (ESO examples don't always have labeled SAs, use naming pattern)
                oc delete serviceaccount "${ns}-sa" -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                
                # Delete namespace (will cascade delete remaining resources)
                oc delete namespace "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
            fi
        done
        
        # Wait for deletions to complete
        print_status "Waiting for ESO resources to be deleted..."
        sleep 2
    else
        print_status "No ESO example namespaces found"
    fi
    
    # Final cleanup: Remove any orphaned resources in non-example namespaces
    # IMPORTANT: This cleanup explicitly excludes operator namespaces to avoid touching installed operators
    print_status "Cleaning up any orphaned example resources (excluding operator namespaces)..."
    
    # Define operator namespaces to exclude from cleanup
    local operator_namespaces=("openshift-cluster-csi-drivers" "external-secrets-operator")
    
    # Clean up test pods in any namespace (in case they weren't in example namespaces)
    # Exclude operator namespaces
    local test_pods_found=false
    for ns in $(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n'); do
        if [[ ! " ${operator_namespaces[@]} " =~ " ${ns} " ]]; then
            if oc get pod -l app=secrets-store-test -n "$ns" --no-headers 2>/dev/null | grep -q .; then
                test_pods_found=true
                oc delete pod -l app=secrets-store-test -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
            fi
        fi
    done
    if [ "$test_pods_found" = true ]; then
        print_status "Cleaned up orphaned test pods"
    fi
    
    # Clean up SecretProviderClasses with example labels (excluding operator namespaces)
    if oc api-resources | grep -q secretproviderclass; then
        local spc_found=false
        for ns in $(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n'); do
            if [[ ! " ${operator_namespaces[@]} " =~ " ${ns} " ]]; then
                if oc get secretproviderclass -l app=secrets-store-examples -n "$ns" --no-headers 2>/dev/null | grep -q .; then
                    spc_found=true
                    oc delete secretproviderclass -l app=secrets-store-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
            fi
        done
        if [ "$spc_found" = true ]; then
            print_status "Cleaned up orphaned SecretProviderClasses"
        fi
    fi
    
    # Clean up ExternalSecrets with example labels (excluding operator namespaces)
    if oc api-resources | grep -q externalsecret; then
        local eso_found=false
        for ns in $(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n'); do
            if [[ ! " ${operator_namespaces[@]} " =~ " ${ns} " ]]; then
                if oc get externalsecret -l app=external-secrets-examples -n "$ns" --no-headers 2>/dev/null | grep -q .; then
                    eso_found=true
                    oc delete externalsecret -l app=external-secrets-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
            fi
        done
        if [ "$eso_found" = true ]; then
            print_status "Cleaned up orphaned ExternalSecrets"
        fi
    fi
    
    # Clean up SecretStores with example labels (excluding operator namespaces)
    if oc api-resources | grep -q secretstore; then
        local ss_found=false
        for ns in $(oc get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n'); do
            if [[ ! " ${operator_namespaces[@]} " =~ " ${ns} " ]]; then
                if oc get secretstore -l app=external-secrets-examples -n "$ns" --no-headers 2>/dev/null | grep -q .; then
                    ss_found=true
                    oc delete secretstore -l app=external-secrets-examples -n "$ns" --ignore-not-found=true --wait=false 2>/dev/null || true
                fi
            fi
        done
        if [ "$ss_found" = true ]; then
            print_status "Cleaned up orphaned SecretStores"
        fi
    fi
    
    print_success "Examples and test resources cleaned up successfully!"
}

# Test an example
test_example() {
    local example_name="$1"
    
    # Find the example file
    local example_file
    if ! example_file=$(get_example_file "$example_name"); then
        print_error "Example not found: $example_name"
        return 1
    fi
    
    local basename=$(basename "$example_file" .yaml)
    
    # Check if required operator is installed
    if ! check_example_requirements "$basename"; then
        return 1
    fi
    
    # Get operator from file location
    local operator=$(get_example_operator_from_file "$example_file")
    local example_namespace="${operator}-${basename}"
    local example_sa="${operator}-${basename}-sa"
    
    print_header "Testing Example: $basename"
    
    # Special handling for namespace-based-rbac: test across multiple namespaces
    if [[ "$basename" == "namespace-based-rbac" ]]; then
        test_namespace_based_rbac "$basename" "$example_file" "$operator"
        return $?
    fi
    
    # Apply the example if not already applied
    apply_example "$basename"
    
    # Handle ESO examples
    if [[ "$operator" == "eso" ]]; then
        test_eso_example "$basename" "$example_file" "$example_namespace"
        return $?
    fi
    
    # Extract the actual SecretProviderClass name from template
    local actual_spc_name=$(grep -E "^metadata:" -A 5 "$example_file" | grep -E "^\s+name:" | awk '{print $2}' || echo "")
    
    if [ -z "$actual_spc_name" ]; then
        # Fallback: try to get the name from the applied resource
        actual_spc_name=$(oc get secretproviderclass -n ${example_namespace} -l app=secrets-store-examples -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "azure-keyvault-basic-secrets")
    fi
    
    print_info "Using SecretProviderClass: ${actual_spc_name}"
    
    # Ensure namespace exists and has proper pod security level for CSI driver
    print_status "Ensuring namespace has proper pod security configuration..."
    oc label namespace ${example_namespace} pod-security.kubernetes.io/enforce=privileged --overwrite 2>/dev/null || true
    oc label namespace ${example_namespace} pod-security.kubernetes.io/audit=privileged --overwrite 2>/dev/null || true
    oc label namespace ${example_namespace} pod-security.kubernetes.io/warn=privileged --overwrite 2>/dev/null || true
    
    # Service account and secret should already exist from apply_example, but verify
    print_status "Verifying service account and secret exist..."
    if ! oc get serviceaccount ${example_sa} -n ${example_namespace} &>/dev/null 2>&1; then
        print_status "Creating service account: ${example_sa}..."
        oc create serviceaccount ${example_sa} -n ${example_namespace} --dry-run=client -o yaml | oc apply -f - 2>/dev/null || true
    fi
    
    # Verify secret exists (should have been created by apply_example)
    if [[ "$operator" == "sscsi" ]]; then
        if ! oc get secret secrets-store-csi-driver-sp -n ${example_namespace} &>/dev/null 2>&1; then
            print_warning "Service principal secret not found. Creating it now..."
            if [ -n "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ] && [ -n "${SERVICE_PRINCIPAL_CLIENT_SECRET:-}" ]; then
                oc create secret generic secrets-store-csi-driver-sp \
                    --from-literal=clientid="${SERVICE_PRINCIPAL_CLIENT_ID}" \
                    --from-literal=clientsecret="${SERVICE_PRINCIPAL_CLIENT_SECRET}" \
                    -n ${example_namespace} \
                    --dry-run=client -o yaml | oc apply -f - 2>&1 || true
                # Add labels for cleanup
                oc label secret secrets-store-csi-driver-sp -n ${example_namespace} \
                    app=secrets-store-examples \
                    component=secret \
                    example="${basename}" \
                    --overwrite 2>/dev/null || true
            else
                print_error "Service principal credentials not found in config.env"
                print_info "Please ensure SERVICE_PRINCIPAL_CLIENT_ID and SERVICE_PRINCIPAL_CLIENT_SECRET are set"
                return 1
            fi
        else
            # Secret exists, ensure it's properly labeled and wait for propagation
            oc label secret secrets-store-csi-driver-sp -n ${example_namespace} \
                app=secrets-store-examples \
                component=secret \
                example="${basename}" \
                --overwrite 2>/dev/null || true
            # Small wait to ensure secret is fully propagated for rotation mechanism
            sleep 1
        fi
    fi
    
    # Create test pod
    print_status "Creating test pod..."
    cat <<EOF | envsubst | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-${actual_spc_name}
  namespace: ${example_namespace}
  labels:
    app: secrets-store-test
    example: ${actual_spc_name}
spec:
  serviceAccountName: ${example_sa}
  containers:
  - name: test-container
    image: registry.redhat.io/ubi8/ubi-minimal:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: secrets-store
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
  - name: secrets-store
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "${actual_spc_name}"
      nodePublishSecretRef:
        name: secrets-store-csi-driver-sp
EOF
    
    # Wait for pod to be ready
    print_status "Waiting for test pod to be ready (timeout: 10s)..."
    if ! timeout 15 oc wait --for=condition=ready pod/test-${actual_spc_name} -n ${example_namespace} --timeout=10s 2>&1; then
        print_error "Pod failed to become ready within 10 seconds"
        print_status "Checking pod status..."
        oc get pod test-${actual_spc_name} -n ${example_namespace} -o wide
        
        print_status "Checking pod events..."
        oc describe pod test-${actual_spc_name} -n ${example_namespace} | grep -A 20 "Events:" || true
        
        # Check for init containers or sidecars that might have logs
        print_status "Checking pod logs..."
        if oc get pod test-${actual_spc_name} -n ${example_namespace} -o jsonpath='{.status.containerStatuses[*].ready}' 2>/dev/null | grep -q "false\|true"; then
            print_status "Main container logs:"
            oc logs pod/test-${actual_spc_name} -n ${example_namespace} --tail=50 2>&1 || true
        fi
        
        # Check for CSI driver/node logs if available
        print_status "Checking for CSI driver errors..."
        oc describe pod test-${actual_spc_name} -n ${example_namespace} | grep -i "error\|failed\|mount" || true
        
        return 1
    fi
    
    # Show mounted secrets
    print_status "Checking mounted secrets..."
    oc exec -n ${example_namespace} pod/test-${actual_spc_name} -- ls -la /mnt/secrets-store/
    
    # For rotating-secrets examples, demonstrate actual rotation
    if [[ "$basename" == "rotating-secrets" ]]; then
        test_secret_rotation "${example_namespace}" "test-${actual_spc_name}" "${ACTUAL_KEYVAULT_NAME:-}"
    fi
    
    print_success "Test completed successfully!"
    print_info "To clean up the test pod: oc delete pod test-${actual_spc_name} -n ${example_namespace}"
}

# Test secret rotation by updating secrets in Key Vault and verifying changes
test_secret_rotation() {
    local namespace="$1"
    local pod_name="$2"
    local keyvault_name="$3"
    
    if [ -z "$keyvault_name" ]; then
        print_warning "Key Vault name not provided, skipping rotation test"
        return 0
    fi
    
    print_header "Testing Secret Rotation"
    print_info "This test will update secrets in Key Vault and verify they are reflected in the pod"
    
    # Check if Azure CLI is available
    if ! command -v az &> /dev/null; then
        print_warning "Azure CLI not found, skipping rotation test"
        return 0
    fi
    
    if ! az account show &>/dev/null; then
        print_warning "Azure CLI not authenticated, skipping rotation test"
        return 0
    fi
    
    # Read initial values from the pod
    print_status "Reading initial secret values from pod..."
    local initial_db_password=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/db-password 2>&1 | tr -d '\r\n' || echo "")
    local initial_api_key=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/api-key 2>&1 | tr -d '\r\n' || echo "")
    local initial_jwt_secret=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/jwt-secret 2>&1 | tr -d '\r\n' || echo "")
    
    # Debug: show what we got (truncated)
    if [ -n "$initial_db_password" ]; then
        print_info "  Successfully read db-password (length: ${#initial_db_password})"
    else
        print_warning "  Failed to read db-password"
    fi
    if [ -n "$initial_api_key" ]; then
        print_info "  Successfully read api-key (length: ${#initial_api_key})"
    else
        print_warning "  Failed to read api-key"
    fi
    if [ -n "$initial_jwt_secret" ]; then
        print_info "  Successfully read jwt-secret (length: ${#initial_jwt_secret})"
    else
        print_warning "  Failed to read jwt-secret"
    fi
    
    if [ -z "$initial_db_password" ] || [ -z "$initial_api_key" ] || [ -z "$initial_jwt_secret" ]; then
        print_warning "Could not read all initial secret values, skipping rotation test"
        print_info "Available files in /mnt/secrets-store:"
        oc exec ${pod_name} -n ${namespace} -- ls -la /mnt/secrets-store/ 2>&1 || true
        return 0
    fi
    
    print_info "Initial values:"
    print_info "  db-password: ${initial_db_password}"
    print_info "  api-key: ${initial_api_key}"
    print_info "  jwt-secret: ${initial_jwt_secret}"
    
    # Update secrets in Key Vault with new values
    print_status "Updating secrets in Key Vault with new values..."
    local new_db_password="RotatingPassword123!v2-$(date +%s)"
    local new_api_key="rotating-api-key-v2-$(date +%s)"
    local new_jwt_secret="rotating-jwt-secret-value-v2-$(date +%s)"
    
    print_info "New values to be set:"
    print_info "  db-password: ${new_db_password}"
    print_info "  api-key: ${new_api_key}"
    print_info "  jwt-secret: ${new_jwt_secret}"
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-database-password" --value "${new_db_password}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-database-password in Key Vault"
    else
        print_warning "Failed to update rotating-database-password"
        return 0
    fi
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-api-key" --value "${new_api_key}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-api-key in Key Vault"
    else
        print_warning "Failed to update rotating-api-key"
        return 0
    fi
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-jwt-secret" --value "${new_jwt_secret}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-jwt-secret in Key Vault"
    else
        print_warning "Failed to update rotating-jwt-secret"
        return 0
    fi
    
    print_status "Waiting for CSI driver to detect changes (may require pod restart)..."
    print_info "Note: Secrets Store CSI Driver typically refreshes on pod restart"
    print_info "For automatic rotation, pods would need to be restarted or use CSI rotation features"
    
    # Get the pod spec before deletion so we can recreate it
    print_status "Saving pod configuration..."
    local pod_yaml=$(oc get pod ${pod_name} -n ${namespace} -o yaml 2>/dev/null || echo "")
    
    if [ -z "$pod_yaml" ]; then
        print_warning "Could not retrieve pod configuration, skipping rotation verification"
        return 0
    fi
    
    # Extract service account and SPC name from the existing pod using YAML parsing
    # Use yq if available, otherwise use grep/awk
    if command -v yq &> /dev/null; then
        local service_account=$(echo "$pod_yaml" | yq eval '.spec.serviceAccountName' - || echo "")
        local spc_name=$(echo "$pod_yaml" | yq eval '.spec.volumes[] | select(.csi != null) | .csi.volumeAttributes.secretProviderClass' - || echo "")
    else
        # Fallback: grep-based extraction
        local service_account=$(echo "$pod_yaml" | grep "serviceAccountName:" | grep -v "#" | awk '{print $2}' || echo "")
        local spc_name=$(echo "$pod_yaml" | grep -B 5 -A 5 "volumeAttributes:" | grep "secretProviderClass:" | awk '{print $2}' || echo "")
    fi
    
    if [ -z "$service_account" ] || [ -z "$spc_name" ]; then
        print_warning "Could not extract pod configuration details, skipping rotation verification"
        return 0
    fi
    
    # Try to trigger refresh by restarting the pod
    print_status "Restarting pod to trigger secret refresh..."
    oc delete pod ${pod_name} -n ${namespace} --wait=true --timeout=30s 2>/dev/null || true
    
    # Wait for the pod to be fully deleted (no longer in API)
    print_status "Waiting for pod to be fully deleted..."
    local delete_wait=0
    while [ $delete_wait -lt 30 ]; do
        if ! oc get pod ${pod_name} -n ${namespace} &>/dev/null; then
            break
        fi
        sleep 2
        delete_wait=$((delete_wait + 2))
    done
    
    if oc get pod ${pod_name} -n ${namespace} &>/dev/null; then
        print_warning "Old pod still exists, forcing deletion..."
        oc delete pod ${pod_name} -n ${namespace} --grace-period=0 --force 2>/dev/null || true
        sleep 3
    fi
    
    # Recreate the pod
    print_status "Recreating pod with updated secrets..."
    cat <<EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${namespace}
  labels:
    app: secrets-store-test
    example: rotation-test
spec:
  serviceAccountName: ${service_account}
  containers:
  - name: test-container
    image: registry.redhat.io/ubi8/ubi-minimal:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: secrets-store
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
  - name: secrets-store
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "${spc_name}"
      nodePublishSecretRef:
        name: secrets-store-csi-driver-sp
EOF
    
    # Wait for pod to be ready
    print_status "Waiting for pod to be ready (timeout: 30s)..."
    if ! oc wait --for=condition=ready pod/${pod_name} -n ${namespace} --timeout=30s 2>&1; then
        print_warning "Pod did not become ready in time, checking status..."
        oc get pod ${pod_name} -n ${namespace} -o wide || true
        return 0
    fi
    
    # Wait a bit more for the pod to fully initialize and secrets to mount
    print_status "Waiting for secrets to mount (5s)..."
    sleep 5
    
    # Verify the pod is actually running (not just ready but maybe terminating)
    local pod_phase=$(oc get pod ${pod_name} -n ${namespace} -o jsonpath='{.status.phase}' 2>/dev/null || echo "")
    if [ "$pod_phase" != "Running" ]; then
        print_warning "Pod is not in Running phase (current: ${pod_phase}), cannot verify rotation"
        oc get pod ${pod_name} -n ${namespace} || true
        return 0
    fi
    
    # Read new values from the pod
    print_status "Reading updated secret values from pod..."
    
    local updated_db_password=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/db-password 2>&1 | tr -d '\r\n' || echo "")
    local updated_api_key=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/api-key 2>&1 | tr -d '\r\n' || echo "")
    local updated_jwt_secret=$(oc exec ${pod_name} -n ${namespace} -- cat /mnt/secrets-store/jwt-secret 2>&1 | tr -d '\r\n' || echo "")
    
    print_info "Updated values:"
    print_info "  db-password: ${updated_db_password}"
    print_info "  api-key: ${updated_api_key}"
    print_info "  jwt-secret: ${updated_jwt_secret}"
    
    # Verify rotation occurred
    local rotation_verified=true
    
    if [ "$updated_db_password" = "$new_db_password" ]; then
        print_success "✓ db-password rotated successfully"
    elif [ "$updated_db_password" != "$initial_db_password" ]; then
        print_warning "⚠ db-password changed but doesn't match expected new value"
    else
        print_warning "⚠ db-password did not rotate (may need manual refresh)"
        rotation_verified=false
    fi
    
    if [ "$updated_api_key" = "$new_api_key" ]; then
        print_success "✓ api-key rotated successfully"
    elif [ "$updated_api_key" != "$initial_api_key" ]; then
        print_warning "⚠ api-key changed but doesn't match expected new value"
    else
        print_warning "⚠ api-key did not rotate (may need manual refresh)"
        rotation_verified=false
    fi
    
    if [ "$updated_jwt_secret" = "$new_jwt_secret" ]; then
        print_success "✓ jwt-secret rotated successfully"
    elif [ "$updated_jwt_secret" != "$initial_jwt_secret" ]; then
        print_warning "⚠ jwt-secret changed but doesn't match expected new value"
    else
        print_warning "⚠ jwt-secret did not rotate (may need manual refresh)"
        rotation_verified=false
    fi
    
    if [ "$rotation_verified" = true ]; then
        print_success "All secrets rotated successfully!"
        print_info "Rotation demonstrated: Secrets updated in Key Vault are now reflected in the pod"
    else
        print_info "Rotation test completed: Some secrets may need additional refresh mechanisms"
        print_info "Note: CSI drivers typically require pod restart for rotation"
    fi
    
    return 0
}

# Test ESO secret rotation by updating secrets in Key Vault and verifying ESO syncs them
test_eso_secret_rotation() {
    local namespace="$1"
    local externalsecret_name="$2"
    local target_secret="$3"
    local keyvault_name="$4"
    
    if [ -z "$keyvault_name" ]; then
        print_warning "Key Vault name not provided, skipping rotation test"
        return 0
    fi
    
    print_header "Testing ESO Secret Rotation"
    print_info "This test will update secrets in Key Vault and verify ESO syncs them to Kubernetes"
    
    # Check if Azure CLI is available
    if ! command -v az &> /dev/null; then
        print_warning "Azure CLI not found, skipping rotation test"
        return 0
    fi
    
    if ! az account show &>/dev/null; then
        print_warning "Azure CLI not authenticated, skipping rotation test"
        return 0
    fi
    
    # Read initial values from the Kubernetes Secret
    print_status "Reading initial secret values from Kubernetes Secret..."
    # Use oc extract as it automatically decodes base64
    local tmp_dir=$(mktemp -d)
    local extract_success=false
    
    # Suppress stdout from oc extract (it prints file paths)
    if oc extract secret/${target_secret} -n ${namespace} --to=${tmp_dir} --confirm >/dev/null 2>&1; then
        # oc extract decodes the base64 automatically
        if [ -f "${tmp_dir}/database-password" ] && [ -s "${tmp_dir}/database-password" ]; then
            initial_db_password=$(cat "${tmp_dir}/database-password" 2>/dev/null | tr -d '\r\n' || echo "")
            [ -n "$initial_db_password" ] && extract_success=true
        fi
        if [ -f "${tmp_dir}/api-key" ] && [ -s "${tmp_dir}/api-key" ]; then
            initial_api_key=$(cat "${tmp_dir}/api-key" 2>/dev/null | tr -d '\r\n' || echo "")
            [ -n "$initial_api_key" ] && extract_success=true
        fi
        if [ -f "${tmp_dir}/jwt-secret" ] && [ -s "${tmp_dir}/jwt-secret" ]; then
            initial_jwt_secret=$(cat "${tmp_dir}/jwt-secret" 2>/dev/null | tr -d '\r\n' || echo "")
            [ -n "$initial_jwt_secret" ] && extract_success=true
        fi
    fi
    
    rm -rf "${tmp_dir}" 2>/dev/null || true
    
    if [ "$extract_success" = false ] || { [ -z "$initial_db_password" ] && [ -z "$initial_api_key" ] && [ -z "$initial_jwt_secret" ]; }; then
        print_warning "Could not read initial secret values using oc extract, trying jq method..."
        local secret_json=$(oc get secret ${target_secret} -n ${namespace} -o json 2>/dev/null || echo "")
        if [ -n "$secret_json" ]; then
            initial_db_password=$(echo "$secret_json" | jq -r '.data["database-password"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
            initial_api_key=$(echo "$secret_json" | jq -r '.data["api-key"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
            initial_jwt_secret=$(echo "$secret_json" | jq -r '.data["jwt-secret"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
        fi
        
        if [ -z "$initial_db_password" ] && [ -z "$initial_api_key" ] && [ -z "$initial_jwt_secret" ]; then
            print_warning "Could not read secret values using any method, skipping rotation test"
            print_info "Secret exists with keys: $(oc get secret ${target_secret} -n ${namespace} -o json | jq -r '.data | keys[]' 2>/dev/null | tr '\n' ' ' || echo 'unknown')"
            return 0
        fi
    fi
    
    print_info "Initial values:"
    [ -n "$initial_db_password" ] && print_info "  database-password: ${initial_db_password}"
    [ -n "$initial_api_key" ] && print_info "  api-key: ${initial_api_key}"
    [ -n "$initial_jwt_secret" ] && print_info "  jwt-secret: ${initial_jwt_secret}"
    
    # Update secrets in Key Vault with new values
    print_status "Updating secrets in Key Vault with new values..."
    local new_db_password="RotatingPassword123!v2-$(date +%s)"
    local new_api_key="rotating-api-key-v2-$(date +%s)"
    local new_jwt_secret="rotating-jwt-secret-value-v2-$(date +%s)"
    
    print_info "New values to be set:"
    print_info "  database-password: ${new_db_password}"
    print_info "  api-key: ${new_api_key}"
    print_info "  jwt-secret: ${new_jwt_secret}"
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-database-password" --value "${new_db_password}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-database-password in Key Vault"
    else
        print_warning "Failed to update rotating-database-password"
        return 0
    fi
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-api-key" --value "${new_api_key}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-api-key in Key Vault"
    else
        print_warning "Failed to update rotating-api-key"
        return 0
    fi
    
    if az keyvault secret set --vault-name "${keyvault_name}" --name "rotating-jwt-secret" --value "${new_jwt_secret}" --only-show-errors 2>/dev/null; then
        print_success "Updated rotating-jwt-secret in Key Vault"
    else
        print_warning "Failed to update rotating-jwt-secret"
        return 0
    fi
    
    # Get refresh interval from ExternalSecret (default to 1h if not specified)
    local refresh_interval=$(oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.spec.refreshInterval}' 2>/dev/null || echo "1h")
    print_status "ExternalSecret refresh interval: ${refresh_interval}"
    print_info "ESO will automatically sync secrets based on the refresh interval"
    print_info "Waiting for ESO to detect changes and sync..."
    
    # Force a refresh by deleting the ExternalSecret and recreating it, or wait for refresh
    # Option 1: Trigger immediate sync by annotating the ExternalSecret (if ESO supports it)
    # Option 2: Wait for the refresh interval or check periodically
    print_status "Forcing refresh by re-annotating ExternalSecret..."
    oc annotate externalsecret ${externalsecret_name} -n ${namespace} \
        "force-sync=$(date +%s)" --overwrite 2>/dev/null || true
    
    # Wait and check for updates (poll every 5 seconds, up to 2 minutes)
    print_status "Waiting for ESO to sync updated secrets (timeout: 2 minutes)..."
    local max_wait=120
    local waited=0
    local rotation_detected=false
    
    while [ $waited -lt $max_wait ]; do
        sleep 5
        waited=$((waited + 5))
        
        # Check if secrets have been updated
        local current_secret_json=$(oc get secret ${target_secret} -n ${namespace} -o json 2>/dev/null || echo "")
        local current_db_password=$(echo "$current_secret_json" | jq -r '.data["database-password"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
        local current_api_key=$(echo "$current_secret_json" | jq -r '.data["api-key"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
        local current_jwt_secret=$(echo "$current_secret_json" | jq -r '.data["jwt-secret"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
        
        # Check if at least one secret has changed
        if [ -n "$current_db_password" ] && [ "$current_db_password" != "$initial_db_password" ] && [ "$current_db_password" = "$new_db_password" ]; then
            rotation_detected=true
            break
        elif [ -n "$current_api_key" ] && [ "$current_api_key" != "$initial_api_key" ] && [ "$current_api_key" = "$new_api_key" ]; then
            rotation_detected=true
            break
        elif [ -n "$current_jwt_secret" ] && [ "$current_jwt_secret" != "$initial_jwt_secret" ] && [ "$current_jwt_secret" = "$new_jwt_secret" ]; then
            rotation_detected=true
            break
        fi
        
        if [ $((waited % 20)) -eq 0 ]; then
            print_info "Still waiting for sync... (${waited}s elapsed, checking ExternalSecret status)"
            oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.status.conditions[?(@.type=="Ready")]}' | jq -r '.' 2>/dev/null || oc get externalsecret ${externalsecret_name} -n ${namespace} || true
        fi
    done
    
    # Read final values
    print_status "Reading updated secret values from Kubernetes Secret..."
    local updated_secret_json=$(oc get secret ${target_secret} -n ${namespace} -o json 2>/dev/null || echo "")
    local updated_db_password=$(echo "$updated_secret_json" | jq -r '.data["database-password"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
    local updated_api_key=$(echo "$updated_secret_json" | jq -r '.data["api-key"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
    local updated_jwt_secret=$(echo "$updated_secret_json" | jq -r '.data["jwt-secret"] // empty' 2>/dev/null | base64 -d 2>/dev/null | tr -d '\r\n' || echo "")
    
    print_info "Updated values:"
    [ -n "$updated_db_password" ] && print_info "  database-password: ${updated_db_password}"
    [ -n "$updated_api_key" ] && print_info "  api-key: ${updated_api_key}"
    [ -n "$updated_jwt_secret" ] && print_info "  jwt-secret: ${updated_jwt_secret}"
    
    # Verify rotation occurred
    local rotation_verified=true
    local all_synced=true
    
    if [ -n "$initial_db_password" ]; then
        if [ "$updated_db_password" = "$new_db_password" ]; then
            print_success "✓ database-password rotated and synced successfully"
        elif [ "$updated_db_password" != "$initial_db_password" ]; then
            print_warning "⚠ database-password changed but doesn't match expected new value"
        else
            print_warning "⚠ database-password did not rotate yet (may sync within refresh interval: ${refresh_interval})"
            all_synced=false
        fi
    fi
    
    if [ -n "$initial_api_key" ]; then
        if [ "$updated_api_key" = "$new_api_key" ]; then
            print_success "✓ api-key rotated and synced successfully"
        elif [ "$updated_api_key" != "$initial_api_key" ]; then
            print_warning "⚠ api-key changed but doesn't match expected new value"
        else
            print_warning "⚠ api-key did not rotate yet (may sync within refresh interval: ${refresh_interval})"
            all_synced=false
        fi
    fi
    
    if [ -n "$initial_jwt_secret" ]; then
        if [ "$updated_jwt_secret" = "$new_jwt_secret" ]; then
            print_success "✓ jwt-secret rotated and synced successfully"
        elif [ "$updated_jwt_secret" != "$initial_jwt_secret" ]; then
            print_warning "⚠ jwt-secret changed but doesn't match expected new value"
        else
            print_warning "⚠ jwt-secret did not rotate yet (may sync within refresh interval: ${refresh_interval})"
            all_synced=false
        fi
    fi
    
    if [ "$all_synced" = true ]; then
        print_success "All secrets rotated and synced successfully!"
        print_info "ESO automatically detected changes in Key Vault and synced them to Kubernetes"
    else
        print_info "Rotation test completed: Some secrets may sync within the refresh interval (${refresh_interval})"
        print_info "ExternalSecret will continue to sync automatically based on its refresh interval"
        print_info "Check sync status: oc describe externalsecret ${externalsecret_name} -n ${namespace}"
    fi
    
    return 0
}

# Test namespace-based-rbac across multiple namespaces
test_namespace_based_rbac() {
    local example_name="$1"
    local example_file="$2"
    local operator="$3"
    
    print_header "Testing Namespace-Based RBAC (Multi-Namespace)"
    print_info "This test will create resources in multiple namespaces to demonstrate RBAC patterns"
    
    # Define test namespaces
    local test_namespaces=("rbac-test-ns1" "rbac-test-ns2" "rbac-test-ns3")
    
    # Ensure required variables are set
    if [ -f "$(dirname "${BASH_SOURCE[0]}")/../config.env" ]; then
        source "$(dirname "${BASH_SOURCE[0]}")/../config.env"
    fi
    
    # Initialize Azure values if not set
    if [ -z "${ACTUAL_KEYVAULT_NAME:-}" ] && [ -n "${KEYVAULT_NAME:-}" ]; then
        export AZURE_RESOURCE_PREFIX="${AZURE_RESOURCE_PREFIX:-aro-secrets-}"
        export ACTUAL_KEYVAULT_NAME="${AZURE_RESOURCE_PREFIX}${KEYVAULT_NAME}"
    fi
    
    # Validate required variables
    if [ -z "${ACTUAL_KEYVAULT_NAME:-}" ] || [ -z "${AZURE_TENANT_ID:-}" ] || [ -z "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ]; then
        print_error "Missing required environment variables for namespace-based-rbac test"
        print_info "Please ensure config.env is properly configured or run './bin/install azure'"
        return 1
    fi
    
    # Create namespace-specific secrets in Key Vault for each test namespace
    print_status "Creating namespace-specific secrets in Key Vault for test namespaces..."
    for ns in "${test_namespaces[@]}"; do
        create_namespace_rbac_secrets "${ns}" "${ACTUAL_KEYVAULT_NAME}"
    done
    
    # Apply SecretProviderClass to each namespace
    print_status "Applying SecretProviderClass to test namespaces..."
    local actual_spc_name=$(grep -E "^metadata:" -A 5 "$example_file" | grep -E "^\s+name:" | awk '{print $2}' || echo "azure-keyvault-namespace-rbac")
    
    for ns in "${test_namespaces[@]}"; do
        print_status "Setting up namespace: ${ns}..."
        
        # Create namespace
        oc create namespace "${ns}" --dry-run=client -o yaml | oc apply -f - 2>/dev/null || true
        
        # Set pod security labels
        oc label namespace "${ns}" pod-security.kubernetes.io/enforce=privileged --overwrite 2>/dev/null || true
        oc label namespace "${ns}" pod-security.kubernetes.io/audit=privileged --overwrite 2>/dev/null || true
        oc label namespace "${ns}" pod-security.kubernetes.io/warn=privileged --overwrite 2>/dev/null || true
        
        # Create service account
        local sa="${ns}-sa"
        oc create serviceaccount "${sa}" -n "${ns}" --dry-run=client -o yaml | oc apply -f - 2>/dev/null || true
        oc label serviceaccount "${sa}" -n "${ns}" \
            app=secrets-store-examples \
            component=serviceaccount \
            example="${example_name}" \
            --overwrite 2>/dev/null || true
        
        # Create service principal secret
        if [ -n "${SERVICE_PRINCIPAL_CLIENT_ID:-}" ] && [ -n "${SERVICE_PRINCIPAL_CLIENT_SECRET:-}" ]; then
            oc create secret generic secrets-store-csi-driver-sp \
                --from-literal=clientid="${SERVICE_PRINCIPAL_CLIENT_ID}" \
                --from-literal=clientsecret="${SERVICE_PRINCIPAL_CLIENT_SECRET}" \
                -n "${ns}" \
                --dry-run=client -o yaml | oc apply -f - 2>&1 || true
            oc label secret secrets-store-csi-driver-sp -n "${ns}" \
                app=secrets-store-examples \
                component=secret \
                example="${example_name}" \
                --overwrite 2>/dev/null || true
        fi
        
        # Apply SecretProviderClass (with namespace substitution)
        export TEST_NAMESPACE="${ns}"
        export NAMESPACE="${ns}"
        export KEYVAULT_NAME="${ACTUAL_KEYVAULT_NAME}"
        envsubst < "$example_file" | oc apply -f - 2>&1 | grep -v "^namespace/" || true
    done
    
    # Wait a moment for resources to settle
    sleep 2
    
    # Create test pods in each namespace
    print_status "Creating test pods in each namespace..."
    local all_pods_ready=true
    
    for ns in "${test_namespaces[@]}"; do
        print_status "Creating test pod in namespace: ${ns}..."
        local sa="${ns}-sa"
        
        cat <<EOF | oc apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-rbac-${ns}
  namespace: ${ns}
  labels:
    app: secrets-store-test
    example: namespace-based-rbac
    namespace: ${ns}
spec:
  serviceAccountName: ${sa}
  containers:
  - name: test-container
    image: registry.redhat.io/ubi8/ubi-minimal:latest
    command: ["sleep", "3600"]
    volumeMounts:
    - name: secrets-store
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
  - name: secrets-store
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: "${actual_spc_name}"
      nodePublishSecretRef:
        name: secrets-store-csi-driver-sp
EOF
        
        # Wait for pod to be ready
        print_status "Waiting for pod in ${ns} to be ready (timeout: 15s)..."
        if timeout 20 oc wait --for=condition=ready pod/test-rbac-${ns} -n "${ns}" --timeout=15s 2>&1; then
            print_success "Pod in ${ns} is ready"
        else
            print_warning "Pod in ${ns} failed to become ready"
            all_pods_ready=false
            
            # Show pod status
            oc get pod test-rbac-${ns} -n "${ns}" -o wide 2>/dev/null || true
            oc describe pod test-rbac-${ns} -n "${ns}" | grep -A 10 "Events:" 2>/dev/null || true
        fi
    done
    
    if [ "$all_pods_ready" = false ]; then
        print_error "Some test pods failed to become ready"
        return 1
    fi
    
    # Verify secrets in each namespace
    print_status "Verifying secrets in each namespace..."
    print_header "RBAC Pattern Verification"
    
    local all_tests_passed=true
    
    for ns in "${test_namespaces[@]}"; do
        print_status "Checking secrets in namespace: ${ns}..."
        
        # Check mounted secrets in the pod
        local mounted_secrets=$(oc exec test-rbac-${ns} -n "${ns}" -- ls -1 /mnt/secrets-store/ 2>/dev/null | grep -v "^\\.\\.$" | grep -v "^\\.\\.data$" | grep -v "^\\.data$" || echo "")
        
        if [ -n "$mounted_secrets" ]; then
            print_success "Namespace ${ns} can access secrets:"
            echo "$mounted_secrets" | while read -r secret; do
                if [ -n "$secret" ]; then
                    echo "  ✓ ${secret}"
                    
                    # Verify this is the correct secret (namespace-specific or shared)
                    if [[ "$secret" == "db-password" ]] || [[ "$secret" == "api-key" ]]; then
                        # These should be namespace-specific
                        print_info "    (namespace-specific: namespace-${ns}-${secret})"
                    elif [[ "$secret" == "shared-config" ]]; then
                        # This should be shared
                        print_info "    (shared: shared-readonly-config)"
                    fi
                fi
            done
            
            # Verify namespace-specific secrets are present
            if echo "$mounted_secrets" | grep -q "db-password" && echo "$mounted_secrets" | grep -q "api-key"; then
                print_success "✓ Namespace-specific secrets present in ${ns}"
            else
                print_warning "⚠ Namespace-specific secrets missing in ${ns}"
                all_tests_passed=false
            fi
            
            # Verify shared secret is present
            if echo "$mounted_secrets" | grep -q "shared-config"; then
                print_success "✓ Shared secret present in ${ns}"
            else
                print_warning "⚠ Shared secret missing in ${ns}"
                all_tests_passed=false
            fi
        else
            print_error "No secrets found in namespace ${ns}"
            all_tests_passed=false
        fi
    done
    
    # Summary
    print_header "Namespace-Based RBAC Test Summary"
    print_info "Test namespaces created: ${#test_namespaces[@]}"
    for ns in "${test_namespaces[@]}"; do
        print_info "  - ${ns}: namespace-${ns}-db-password, namespace-${ns}-api-key"
    done
    print_info "  - All namespaces: shared-readonly-config (shared)"
    
    if [ "$all_tests_passed" = true ]; then
        print_success "All namespace-based RBAC tests passed!"
        print_info "Each namespace can access:"
        print_info "  • Its own namespace-specific secrets (isolated)"
        print_info "  • Shared secrets (accessible to all)"
        print_info ""
        print_info "To verify isolation, check that pods cannot access other namespaces' secrets"
    else
        print_warning "Some tests had issues. Please check the output above."
    fi
    
    print_info "To clean up: ./bin/examples cleanup"
    
    return 0
}

# Test ESO examples
test_eso_example() {
    local basename="$1"
    local example_file="$2"
    local example_namespace="$3"
    
    # Determine example type based on basename or file content
    if [[ "$basename" == *"secretstore"* ]]; then
        test_secretstore "$example_namespace"
    elif [[ "$basename" == *"externalsecret"* ]]; then
        test_externalsecret "$example_file" "$example_namespace" "$basename"
    else
        print_warning "Unknown ESO example type: $basename"
        print_info "Checking for SecretStore resources..."
        oc get secretstore -n ${example_namespace} 2>/dev/null || true
        print_info "Checking for ExternalSecret resources..."
        oc get externalsecret -n ${example_namespace} 2>/dev/null || true
        return 1
    fi
}

# Test SecretStore example
test_secretstore() {
    local namespace="$1"
    local secretstore_name="azure-keyvault-secretstore"
    
    print_status "Testing SecretStore: ${secretstore_name}..."
    
    # Check if SecretStore exists
    if ! oc get secretstore ${secretstore_name} -n ${namespace} &>/dev/null; then
        print_error "SecretStore ${secretstore_name} not found in namespace ${namespace}"
        return 1
    fi
    
    # Get SecretStore status
    local ready=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.ready}' 2>/dev/null || echo "")
    local store_status=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.status}' 2>/dev/null || echo "")
    local capabilities=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.capabilities}' 2>/dev/null || echo "")
    
    print_status "Checking SecretStore status..."
    oc get secretstore ${secretstore_name} -n ${namespace}
    
    if [[ "$ready" == "true" ]] && [[ "$store_status" == "Valid" ]]; then
        print_success "SecretStore is Valid and Ready!"
        if [ -n "$capabilities" ]; then
            print_info "Capabilities: ${capabilities}"
        fi
    else
        print_warning "SecretStore status: Ready=${ready}, Status=${store_status}"
        
        # Check for conditions or events that might explain the issue
        print_status "Checking SecretStore details..."
        oc describe secretstore ${secretstore_name} -n ${namespace} | grep -A 10 "Status:\|Events:" || true
    fi
    
    # Check if the referenced secret exists
    print_status "Verifying Service Principal secret exists..."
    local secret_name=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.spec.provider.azurekv.authSecretRef.clientId.name}' 2>/dev/null || echo "")
    if [ -n "$secret_name" ]; then
        if oc get secret ${secret_name} -n ${namespace} &>/dev/null; then
            print_success "Service Principal secret '${secret_name}' exists"
        else
            print_error "Service Principal secret '${secret_name}' not found"
            return 1
        fi
    fi
    
    # Wait a bit and check again to see if status improves
    print_status "Waiting 5 seconds for validation..."
    sleep 5
    local final_status=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.status}' 2>/dev/null || echo "")
    local final_ready=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.ready}' 2>/dev/null || echo "")
    
    # Final check using oc get output
    local final_check=$(oc get secretstore ${secretstore_name} -n ${namespace} -o jsonpath='{.status.status}{"|"}{.status.ready}' 2>/dev/null || echo "")
    
    if [[ "$final_ready" == "true" ]] && [[ "$final_status" == "Valid" ]]; then
        print_success "SecretStore test completed successfully!"
        print_info "SecretStore is validated and ready to use"
        return 0
    elif [ -z "$final_status" ] || [ -z "$final_ready" ]; then
        # Check using oc get table output as fallback
        local table_output=$(oc get secretstore ${secretstore_name} -n ${namespace} --no-headers 2>/dev/null || echo "")
        if echo "$table_output" | grep -q "Valid.*True"; then
            print_success "SecretStore test completed successfully!"
            print_info "SecretStore is validated and ready to use"
            return 0
        fi
    fi
    
    # Final status check
    print_status "Final status check..."
    oc get secretstore ${secretstore_name} -n ${namespace}
    
    if oc get secretstore ${secretstore_name} -n ${namespace} --no-headers 2>/dev/null | grep -q "Valid.*True"; then
        print_success "SecretStore test completed successfully!"
        return 0
    else
        print_warning "SecretStore status may still be initializing"
        print_info "Current status shown above - check manually if needed: oc describe secretstore ${secretstore_name} -n ${namespace}"
        return 0  # Don't fail, as this might be temporary
    fi
}

# Test ExternalSecret example
test_externalsecret() {
    local example_file="$1"
    local namespace="$2"
    local basename="${3:-}"  # Optional: example basename to detect rotation examples
    
    # Extract ExternalSecret name from the file
    # Look for the ExternalSecret kind specifically, not all resources
    local externalsecret_name=$(awk '/^kind: ExternalSecret$/,/^metadata:/ {if (/^kind: ExternalSecret$/) {found=1} else if (found && /^\s+name:/) {print $2; exit}}' "$example_file" || echo "")
    
    if [ -z "$externalsecret_name" ]; then
        # Fallback: try to get the first ExternalSecret in the namespace
        externalsecret_name=$(oc get externalsecret -n ${namespace} -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
    fi
    
    if [ -z "$externalsecret_name" ]; then
        print_error "ExternalSecret not found in namespace ${namespace}"
        return 1
    fi
    
    print_status "Testing ExternalSecret: ${externalsecret_name}..."
    
    # Check if ExternalSecret exists
    if ! oc get externalsecret ${externalsecret_name} -n ${namespace} &>/dev/null; then
        print_error "ExternalSecret ${externalsecret_name} not found in namespace ${namespace}"
        return 1
    fi
    
    print_status "Checking ExternalSecret status..."
    oc get externalsecret ${externalsecret_name} -n ${namespace}
    
    # Get the target secret name
    local target_secret=$(oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.spec.target.name}' 2>/dev/null || echo "")
    
    if [ -z "$target_secret" ]; then
        print_warning "Target secret name not found in ExternalSecret spec"
    else
        print_status "Waiting for synced secret '${target_secret}' to be created..."
        
        # Wait up to 60 seconds for the secret to be created
        local wait_count=0
        while [ $wait_count -lt 30 ]; do
            if oc get secret ${target_secret} -n ${namespace} &>/dev/null; then
                print_success "Synced secret '${target_secret}' created!"
                break
            fi
            sleep 2
            wait_count=$((wait_count + 1))
        done
        
        if oc get secret ${target_secret} -n ${namespace} &>/dev/null; then
            print_status "Checking synced secret contents..."
            oc get secret ${target_secret} -n ${namespace}
            
            # Get the secret keys
            local secret_keys=$(oc get secret ${target_secret} -n ${namespace} -o jsonpath='{.data}' 2>/dev/null | jq -r 'keys[]' 2>/dev/null || echo "")
            
            if [ -n "$secret_keys" ]; then
                print_success "Secret contains the following keys:"
                echo "$secret_keys" | while read -r key; do
                    if [ -n "$key" ]; then
                        echo "  - ${key}"
                    fi
                done
            fi
            
            # For rotating-externalsecret examples, demonstrate actual rotation
            if [[ "$basename" == "rotating-externalsecret" ]]; then
                test_eso_secret_rotation "${namespace}" "${externalsecret_name}" "${target_secret}" "${ACTUAL_KEYVAULT_NAME:-}"
            fi
        else
            print_warning "Synced secret '${target_secret}' not created yet"
            print_info "This might be because:"
            print_info "  1. The SecretStore is not valid/ready"
            print_info "  2. The secrets don't exist in Azure Key Vault"
            print_info "  3. The ExternalSecret is still processing"
            print_info ""
            print_info "Check ExternalSecret status: oc describe externalsecret ${externalsecret_name} -n ${namespace}"
        fi
    fi
    
    # Check ExternalSecret status
    local eso_status=$(oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")
    local ready=$(oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.status.conditions[?(@.type=="Ready")].reason}' 2>/dev/null || echo "")
    
    if [[ "$eso_status" == "True" ]] && [[ "$ready" == "SecretSynced" ]]; then
        print_success "ExternalSecret test completed successfully!"
        print_info "ExternalSecret is syncing secrets from Azure Key Vault"
        return 0
    else
        local current_status=$(oc get externalsecret ${externalsecret_name} -n ${namespace} -o jsonpath='{.status.conditions[?(@.type=="Ready")].message}' 2>/dev/null || echo "")
        print_warning "ExternalSecret status: ${eso_status}, Reason: ${ready}"
        if [ -n "$current_status" ]; then
            print_info "Status message: ${current_status}"
        fi
        
        print_status "Checking ExternalSecret details..."
        oc describe externalsecret ${externalsecret_name} -n ${namespace} | grep -A 10 "Status:\|Events:" || true
        
        print_info "Note: ExternalSecret may be processing or waiting for SecretStore validation"
        return 0  # Don't fail, as syncing might take time
    fi
}

# Show help
show_help() {
    echo "Examples Helper Script"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  list                    - List all available examples"
    echo "  apply <example>         - Apply a specific example"
    echo "  apply-all               - Apply all examples (skips missing operators)"
    echo "  apply --sscsi           - Apply all Secrets Store CSI Driver examples"
    echo "  apply --eso             - Apply all External Secrets Operator examples"
    echo "  test <example>          - Test a specific example with a pod"
    echo "  cleanup                 - Clean up all examples and test resources"
    echo "  help                    - Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 list"
    echo "  $0 apply basic-secret-sync"
    echo "  $0 apply examples/basic-secret-sync.yaml"
    echo "  $0 apply --sscsi"
    echo "  $0 apply --eso"
    echo "  $0 apply-all"
    echo "  $0 test basic-secret-sync"
    echo "  $0 cleanup"
    echo ""
    echo "Note: The script will automatically skip examples if their required operators"
    echo "      are not installed, with helpful installation instructions."
}

# Main script logic
# Check authentication first (except for help/list which don't need auth)
case "${1:-help}" in
    "help"|"--help"|"-h")
        show_help
        ;;
    "list")
        # List doesn't need full auth, just check basic connectivity
        if ! oc whoami &>/dev/null; then
            echo -e "${YELLOW}⚠️${NC} Not authenticated - some information may be unavailable"
        fi
        list_examples
        ;;
    *)
        # For all other commands, verify authentication
        if ! check_cluster_auth; then
            exit 1
        fi
        
        case "${1}" in
    "apply")
        if [ -z "${2:-}" ]; then
                    print_error "Please specify an example to apply or an operator (--sscsi or --eso)"
            show_help
            exit 1
        fi
                
                # Check if it's an operator flag
                if [[ "$2" == "--sscsi" ]]; then
                    apply_operator_examples "sscsi"
                elif [[ "$2" == "--eso" ]]; then
                    apply_operator_examples "eso"
                else
                    # Apply a specific example
        apply_example "$2"
                fi
        ;;
    "apply-all")
        apply_all_examples
        ;;
    "test")
        if [ -z "${2:-}" ]; then
            print_error "Please specify an example to test"
            show_help
            exit 1
        fi
        test_example "$2"
        ;;
    "cleanup")
        cleanup_examples
        ;;
            *)
        show_help
                ;;
        esac
        ;;
esac
